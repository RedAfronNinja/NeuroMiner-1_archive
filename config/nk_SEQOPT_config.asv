function [act, SEQOPT ] = nk_SEQOPT_config(SEQOPT, defaultsfl)

if ~exist('defaultsfl','var') || isempty(defaultsfl), defaultsfl = false; end

if ~defaultsfl 
    
    MODEARR = {'The population to be propagated','The entire population'}; MODESTR = MODEARR{SEQOPT.Mode};
    MnuStr = sprintf('Optimization using [ %s ]', MODESTR);                                                    MnuAct = 1;
    
    REPLACEARR = {'Replacement','Mean across predictions'};  REPLACESTR = REPLACEARR{SEQOPT.ReplaceMode};
    MnuStr = sprintf('%s|Define computation mode for combining sequential predictions [ %s ]',MnuStr, REPLACESTR); MnuAct = [MnuAct 2];
    
    ANCHORARR = {'Decision boundary','Median'}; ANCHORSTR = ANCHORARR{SEQOPT.AnchorType};
    MnuStr = sprintf('%s|Define propagation algorithm''s anchor [ %s ]',MnuStr, ANCHORSTR);                    MnuAct = [MnuAct 3];
    
    OPTIMARR = {'Optimization criterion','Mean decision distance between classes'}; OPTIMSTR = OPTIMARR{SEQOPT.PerfMode};
    MnuStr = sprintf('%s|Define optimisation mode [ %s ]', MnuStr, OPTIMSTR);                                  MnuAct = [MnuAct 4];
    
    SEQSTR = {
    
    nk_PrintLogo
    act = nk_input('Select action',0,'mq', MnuStr, MnuAct, 1);
    switch act
        case 1
            SEQOPT.Mode = nk_input('Define training population flag for optimization',0,'mq','The population to be propagated|The entire population',[1,2],SEQOPT.Mode);
        case 2
            SEQOPT.ReplaceMode = nk_input('Sequential decision computation',0,'mq','Replacement|Mean across predictions',[1,2],SEQOPT.ReplaceMode);
        case 3
            SEQOPT.AnchorType = nk_input('Anchor stepping to model''s decision boundary or decision score median',0,'mq','Decision boundary|Median',[1,2], SEQOPT.AnchorType);
        case 4
            
    end
else
    act =0; SEQOPT = struct('Mode', 1, 'ReplaceMode', 1, 'AnchorType', 1),; 
end


